/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../../common";

export interface IJackMarketInterface extends Interface {
  getFunction(
    nameOrSignature: "mint" | "mintXToken" | "mintaToken" | "redeem"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AddCollateral"
      | "Mint"
      | "Redeem"
      | "SelfLiquidate"
      | "UpdateGateway"
      | "UserLiquidate"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "mint",
    values: [BigNumberish, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mintXToken",
    values: [BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mintaToken",
    values: [BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "redeem",
    values: [BigNumberish, BigNumberish, AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintXToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintaToken", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
}

export namespace AddCollateralEvent {
  export type InputTuple = [
    owner: AddressLike,
    recipient: AddressLike,
    baseTokenIn: BigNumberish,
    xTokenMinted: BigNumberish
  ];
  export type OutputTuple = [
    owner: string,
    recipient: string,
    baseTokenIn: bigint,
    xTokenMinted: bigint
  ];
  export interface OutputObject {
    owner: string;
    recipient: string;
    baseTokenIn: bigint;
    xTokenMinted: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace MintEvent {
  export type InputTuple = [
    owner: AddressLike,
    recipient: AddressLike,
    baseTokenIn: BigNumberish,
    aTokenOut: BigNumberish,
    xTokenOut: BigNumberish,
    mintFee: BigNumberish
  ];
  export type OutputTuple = [
    owner: string,
    recipient: string,
    baseTokenIn: bigint,
    aTokenOut: bigint,
    xTokenOut: bigint,
    mintFee: bigint
  ];
  export interface OutputObject {
    owner: string;
    recipient: string;
    baseTokenIn: bigint;
    aTokenOut: bigint;
    xTokenOut: bigint;
    mintFee: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RedeemEvent {
  export type InputTuple = [
    owner: AddressLike,
    recipient: AddressLike,
    aTokenBurned: BigNumberish,
    xTokenBurned: BigNumberish,
    baseTokenOut: BigNumberish,
    redeemFee: BigNumberish
  ];
  export type OutputTuple = [
    owner: string,
    recipient: string,
    aTokenBurned: bigint,
    xTokenBurned: bigint,
    baseTokenOut: bigint,
    redeemFee: bigint
  ];
  export interface OutputObject {
    owner: string;
    recipient: string;
    aTokenBurned: bigint;
    xTokenBurned: bigint;
    baseTokenOut: bigint;
    redeemFee: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SelfLiquidateEvent {
  export type InputTuple = [
    caller: AddressLike,
    baseSwapAmt: BigNumberish,
    baseTokenOut: BigNumberish,
    aTokenBurned: BigNumberish
  ];
  export type OutputTuple = [
    caller: string,
    baseSwapAmt: bigint,
    baseTokenOut: bigint,
    aTokenBurned: bigint
  ];
  export interface OutputObject {
    caller: string;
    baseSwapAmt: bigint;
    baseTokenOut: bigint;
    aTokenBurned: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UpdateGatewayEvent {
  export type InputTuple = [gateway: AddressLike];
  export type OutputTuple = [gateway: string];
  export interface OutputObject {
    gateway: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace UserLiquidateEvent {
  export type InputTuple = [
    owner: AddressLike,
    recipient: AddressLike,
    aTokenBurned: BigNumberish,
    baseTokenOut: BigNumberish
  ];
  export type OutputTuple = [
    owner: string,
    recipient: string,
    aTokenBurned: bigint,
    baseTokenOut: bigint
  ];
  export interface OutputObject {
    owner: string;
    recipient: string;
    aTokenBurned: bigint;
    baseTokenOut: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IJackMarket extends BaseContract {
  connect(runner?: ContractRunner | null): IJackMarket;
  waitForDeployment(): Promise<this>;

  interface: IJackMarketInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  mint: TypedContractMethod<
    [
      baseIn: BigNumberish,
      recipient: AddressLike,
      minaTokenMinted: BigNumberish,
      minXTokenMinted: BigNumberish
    ],
    [[bigint, bigint] & { aTokenMinted: bigint; xTokenMinted: bigint }],
    "nonpayable"
  >;

  mintXToken: TypedContractMethod<
    [
      baseIn: BigNumberish,
      recipient: AddressLike,
      minXTokenMinted: BigNumberish
    ],
    [[bigint, bigint] & { xTokenMinted: bigint; bonus: bigint }],
    "nonpayable"
  >;

  mintaToken: TypedContractMethod<
    [
      baseIn: BigNumberish,
      recipient: AddressLike,
      minaTokenMinted: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;

  redeem: TypedContractMethod<
    [
      aTokenIn: BigNumberish,
      xTokenIn: BigNumberish,
      recipient: AddressLike,
      minBaseOut: BigNumberish
    ],
    [[bigint, bigint] & { baseOut: bigint; bonus: bigint }],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "mint"
  ): TypedContractMethod<
    [
      baseIn: BigNumberish,
      recipient: AddressLike,
      minaTokenMinted: BigNumberish,
      minXTokenMinted: BigNumberish
    ],
    [[bigint, bigint] & { aTokenMinted: bigint; xTokenMinted: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "mintXToken"
  ): TypedContractMethod<
    [
      baseIn: BigNumberish,
      recipient: AddressLike,
      minXTokenMinted: BigNumberish
    ],
    [[bigint, bigint] & { xTokenMinted: bigint; bonus: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "mintaToken"
  ): TypedContractMethod<
    [
      baseIn: BigNumberish,
      recipient: AddressLike,
      minaTokenMinted: BigNumberish
    ],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "redeem"
  ): TypedContractMethod<
    [
      aTokenIn: BigNumberish,
      xTokenIn: BigNumberish,
      recipient: AddressLike,
      minBaseOut: BigNumberish
    ],
    [[bigint, bigint] & { baseOut: bigint; bonus: bigint }],
    "nonpayable"
  >;

  getEvent(
    key: "AddCollateral"
  ): TypedContractEvent<
    AddCollateralEvent.InputTuple,
    AddCollateralEvent.OutputTuple,
    AddCollateralEvent.OutputObject
  >;
  getEvent(
    key: "Mint"
  ): TypedContractEvent<
    MintEvent.InputTuple,
    MintEvent.OutputTuple,
    MintEvent.OutputObject
  >;
  getEvent(
    key: "Redeem"
  ): TypedContractEvent<
    RedeemEvent.InputTuple,
    RedeemEvent.OutputTuple,
    RedeemEvent.OutputObject
  >;
  getEvent(
    key: "SelfLiquidate"
  ): TypedContractEvent<
    SelfLiquidateEvent.InputTuple,
    SelfLiquidateEvent.OutputTuple,
    SelfLiquidateEvent.OutputObject
  >;
  getEvent(
    key: "UpdateGateway"
  ): TypedContractEvent<
    UpdateGatewayEvent.InputTuple,
    UpdateGatewayEvent.OutputTuple,
    UpdateGatewayEvent.OutputObject
  >;
  getEvent(
    key: "UserLiquidate"
  ): TypedContractEvent<
    UserLiquidateEvent.InputTuple,
    UserLiquidateEvent.OutputTuple,
    UserLiquidateEvent.OutputObject
  >;

  filters: {
    "AddCollateral(address,address,uint256,uint256)": TypedContractEvent<
      AddCollateralEvent.InputTuple,
      AddCollateralEvent.OutputTuple,
      AddCollateralEvent.OutputObject
    >;
    AddCollateral: TypedContractEvent<
      AddCollateralEvent.InputTuple,
      AddCollateralEvent.OutputTuple,
      AddCollateralEvent.OutputObject
    >;

    "Mint(address,address,uint256,uint256,uint256,uint256)": TypedContractEvent<
      MintEvent.InputTuple,
      MintEvent.OutputTuple,
      MintEvent.OutputObject
    >;
    Mint: TypedContractEvent<
      MintEvent.InputTuple,
      MintEvent.OutputTuple,
      MintEvent.OutputObject
    >;

    "Redeem(address,address,uint256,uint256,uint256,uint256)": TypedContractEvent<
      RedeemEvent.InputTuple,
      RedeemEvent.OutputTuple,
      RedeemEvent.OutputObject
    >;
    Redeem: TypedContractEvent<
      RedeemEvent.InputTuple,
      RedeemEvent.OutputTuple,
      RedeemEvent.OutputObject
    >;

    "SelfLiquidate(address,uint256,uint256,uint256)": TypedContractEvent<
      SelfLiquidateEvent.InputTuple,
      SelfLiquidateEvent.OutputTuple,
      SelfLiquidateEvent.OutputObject
    >;
    SelfLiquidate: TypedContractEvent<
      SelfLiquidateEvent.InputTuple,
      SelfLiquidateEvent.OutputTuple,
      SelfLiquidateEvent.OutputObject
    >;

    "UpdateGateway(address)": TypedContractEvent<
      UpdateGatewayEvent.InputTuple,
      UpdateGatewayEvent.OutputTuple,
      UpdateGatewayEvent.OutputObject
    >;
    UpdateGateway: TypedContractEvent<
      UpdateGatewayEvent.InputTuple,
      UpdateGatewayEvent.OutputTuple,
      UpdateGatewayEvent.OutputObject
    >;

    "UserLiquidate(address,address,uint256,uint256)": TypedContractEvent<
      UserLiquidateEvent.InputTuple,
      UserLiquidateEvent.OutputTuple,
      UserLiquidateEvent.OutputObject
    >;
    UserLiquidate: TypedContractEvent<
      UserLiquidateEvent.InputTuple,
      UserLiquidateEvent.OutputTuple,
      UserLiquidateEvent.OutputObject
    >;
  };
}
